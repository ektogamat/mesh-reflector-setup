import{DepthFormat,DepthTexture,LinearFilter,Matrix4,MeshStandardMaterial,PerspectiveCamera,Plane,UnsignedShortType,Vector3,Vector4,WebGLRenderTarget}from"three";import*as POSTPROCESSING from"postprocessing";export class MeshReflectorMaterial extends MeshStandardMaterial{constructor(e,t,r,i,{mixBlur:a=0,mixStrength:o=1,resolution:n=256,blur:s=[0,0],minDepthThreshold:l=.9,maxDepthThreshold:h=1,depthScale:m=0,depthToBlurRatioBias:f=.25,mirror:u=0,distortion:d=1,mixContrast:c=1,distortionMap:p,reflectorOffset:x=0,bufferSamples:v=8,planeNormal:g=new Vector3(0,0,1)}={}){super(),this.gl=e,this.camera=t,this.scene=r,this.parent=i,this.hasBlur=s[0]+s[1]>0,this.reflectorPlane=new Plane,this.normal=new Vector3,this.reflectorWorldPosition=new Vector3,this.cameraWorldPosition=new Vector3,this.rotationMatrix=new Matrix4,this.lookAtPosition=new Vector3(0,-1,0),this.clipPlane=new Vector4,this.view=new Vector3,this.target=new Vector3,this.q=new Vector4,this.textureMatrix=new Matrix4,this.virtualCamera=new PerspectiveCamera,this.reflectorOffset=x,this.planeNormal=g,this.setupBuffers(n,s,v),this.reflectorProps={mirror:u,textureMatrix:this.textureMatrix,mixBlur:a,tDiffuse:this.fbo1.texture,tDepth:this.fbo1.depthTexture,tDiffuseBlur:this.fbo2.texture,hasBlur:this.hasBlur,mixStrength:o,minDepthThreshold:l,maxDepthThreshold:h,depthScale:m,depthToBlurRatioBias:f,distortion:d,distortionMap:p,mixContrast:c,"defines-USE_BLUR":this.hasBlur?"":void 0,"defines-USE_DEPTH":m>0?"":void 0,"defines-USE_DISTORTION":p?"":void 0}}setupBuffers(e,t,r){const i={minFilter:LinearFilter,magFilter:LinearFilter,encoding:this.gl.outputEncoding},a=new WebGLRenderTarget(e,e,i);a.depthBuffer=!0,a.depthTexture=new DepthTexture(e,e),a.depthTexture.format=DepthFormat,a.depthTexture.type=UnsignedShortType;const o=new WebGLRenderTarget(e,e,i);this.gl.capabilities.isWebGL2&&(a.samples=r),this.fbo1=a,this.fbo2=o,this.kawaseBlurPass=new POSTPROCESSING.KawaseBlurPass,this.kawaseBlurPass.setSize(t[0],t[1])}beforeRender(){if(!this.parent)return;if(this.reflectorWorldPosition.setFromMatrixPosition(this.parent.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.parent.matrixWorld),this.normal.copy(this.planeNormal),this.normal.applyMatrix4(this.rotationMatrix),this.reflectorWorldPosition.addScaledVector(this.normal,this.reflectorOffset),this.view.subVectors(this.reflectorWorldPosition,this.cameraWorldPosition),this.view.dot(this.normal)>0)return;this.view.reflect(this.normal).negate(),this.view.add(this.reflectorWorldPosition),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition),this.target.subVectors(this.reflectorWorldPosition,this.lookAtPosition),this.target.reflect(this.normal).negate(),this.target.add(this.reflectorWorldPosition),this.virtualCamera.position.copy(this.view),this.virtualCamera.up.set(0,1,0),this.virtualCamera.up.applyMatrix4(this.rotationMatrix),this.virtualCamera.up.reflect(this.normal),this.virtualCamera.lookAt(this.target),this.virtualCamera.far=this.camera.far,this.virtualCamera.updateMatrixWorld(),this.virtualCamera.projectionMatrix.copy(this.camera.projectionMatrix),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.virtualCamera.projectionMatrix),this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse),this.textureMatrix.multiply(this.parent.matrixWorld),this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal,this.reflectorWorldPosition),this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse),this.clipPlane.set(this.reflectorPlane.normal.x,this.reflectorPlane.normal.y,this.reflectorPlane.normal.z,this.reflectorPlane.constant);const e=this.virtualCamera.projectionMatrix;this.q.x=(Math.sign(this.clipPlane.x)+e.elements[8])/e.elements[0],this.q.y=(Math.sign(this.clipPlane.y)+e.elements[9])/e.elements[5],this.q.z=-1,this.q.w=(1+e.elements[10])/e.elements[14],this.clipPlane.multiplyScalar(2/this.clipPlane.dot(this.q)),e.elements[2]=this.clipPlane.x,e.elements[6]=this.clipPlane.y,e.elements[10]=this.clipPlane.z+1,e.elements[14]=this.clipPlane.w}update(){if(this.parent.material!==this)return;this.parent.visible=!1;const e=this.gl.xr.enabled,t=this.gl.shadowMap.autoUpdate;this.beforeRender(),this.gl.xr.enabled=!1,this.gl.shadowMap.autoUpdate=!1,this.gl.setRenderTarget(this.fbo1),this.gl.state.buffers.depth.setMask(!0),this.gl.autoClear||this.gl.clear(),this.gl.render(this.scene,this.virtualCamera),this.hasBlur&&this.kawaseBlurPass.render(this.gl,this.fbo1,this.fbo2),this.gl.xr.enabled=e,this.gl.shadowMap.autoUpdate=t,this.parent.visible=!0,this.gl.setRenderTarget(null)}onBeforeCompile(e,...t){super.onBeforeCompile(e,...t),e.defines?.USE_UV||(e.defines.USE_UV=""),e.defines.USE_DEPTH=!0,e.defines.USE_BLUR=this.hasBlur;let r=this.reflectorProps;for(let t in r)e.uniforms[t]={get value(){return r[t]}};e.vertexShader=`\n            uniform mat4 textureMatrix;\n            varying vec4 my_vUv;     \n          ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n          #include <project_vertex>\n          my_vUv = textureMatrix * vec4( position, 1.0 );\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n          "),e.fragmentShader=`\n            uniform sampler2D tDiffuse;\n            uniform sampler2D tDiffuseBlur;\n            uniform sampler2D tDepth;\n            uniform sampler2D distortionMap;\n            uniform float distortion;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            uniform bool hasBlur;\n            uniform float mixBlur;\n            uniform float mirror;\n            uniform float mixStrength;\n            uniform float minDepthThreshold;\n            uniform float maxDepthThreshold;\n            uniform float mixContrast;\n            uniform float depthScale;\n            uniform float depthToBlurRatioBias;\n            varying vec4 my_vUv;        \n            ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","\n          #include <emissivemap_fragment>\n        \n          float distortionFactor = 0.0;\n          #ifdef USE_DISTORTION\n            distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n          #endif\n    \n          vec4 new_vUv = my_vUv;\n          new_vUv.x += distortionFactor;\n          new_vUv.y += distortionFactor;\n    \n          vec4 base = texture2DProj(tDiffuse, new_vUv);\n          vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n          \n          vec4 merge = base;\n          \n          #ifdef USE_NORMALMAP\n            vec2 normal_uv = vec2(0.0);\n            \n            vec3 coord = new_vUv.xyz / new_vUv.w;\n            normal_uv = coord.xy + coord.z * normal.xz * 0.1;\n            \n            vec4 base_normal = texture2D(tDiffuse, normal_uv);\n            vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n\n            merge = base_normal;\n            blur = blur_normal;\n          #endif\n    \n          float depthFactor = 0.0001;\n          float blurFactor = 0.0;\n    \n          #ifdef USE_DEPTH\n            vec4 depth = texture2DProj(tDepth, new_vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0001, min(1.0, depthFactor));\n    \n            #ifdef USE_BLUR\n              blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n              merge = merge * min(1.0, depthFactor + 0.5);\n            #else\n              merge = merge * depthFactor;\n            #endif\n      \n          #endif\n    \n          float reflectorRoughnessFactor = roughness;\n          #ifdef USE_ROUGHNESSMAP\n            vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n            \n            reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n          #endif\n          \n          #ifdef USE_BLUR\n            blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n            merge = mix(merge, blur, blurFactor);\n          #endif\n    \n          vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n          newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n          newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n          newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n          // need to use max due to adjusting the contrast\n          vec3 reflectionClr = max(vec3(0.), newMerge.rgb) * mixStrength;\n          \n          diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectionClr);\n          ")}}